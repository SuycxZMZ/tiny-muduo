# Muduo 日志模块设计

异步日志的好处是前台线程不会阻塞在写日志上，后台线程真正写日志时，日志消息往往已经积累了很多，此时只需一次 IO 操作，从而减少了 IO 函数的调用次数，提高了效率。

Muduo日志大体可以分为前端和后端两部分：
- 前端：生成日志消息到缓冲区
- 后端：将缓冲区中的日志消息输出到本地文件

日志的前端与后端就是一个典型的 "多生产者——单消费者" 问题：
- 对于生产者而言，要尽可能坐到低延迟、低 CPU 开销、无阻塞；
- 对于消费者而言，要做到足够大的吞吐量，并占用少的资源；
  
对于日志消息而言，要做到以下几点：
- 每条日志消息占一行，且格式明确，便于 awk、grep 工具分析；
- 打印线程ID、日志级别、源文件、行号；
- 时间戳精确到微秒；
- 对于分布式系统而言，使用 GMT 时区；

## 设计思路

每一次日志操作，都进行三个步骤：(1)打开文件;(2)写文件;(3)关闭文件;

但是，当写入日志的频率较高时，磁盘 IO 占用较高。尽管在多线程文件操作中是线程安全的，但是多个线程写入日志的顺序确难以保证。

同时，如果单次输出的日志量太少，从打开文件、写文件到关闭文件耗费了太多的 IO 时间。

为此，可以在应用程序启动之初打开全局文件一次，后续每次日志操作，只需写入文件即可。

由于文件操作默认是存在缓冲区的，只有当缓冲区存满后，才将缓冲区的内容输出到文件中。相较于频繁的打开文件，此方案减少了打开文件、关闭文件的次数，效率得到了提升。

    C++ 中的 ostream 并非线程安全，而 C 中的 fwrite 则是线程安全的。

muduo 库所采用的双缓冲技术，前端负责向 Buffer 中填入数据，后端则负责将 Buffer 中的数据取出来写入到文件。

## 设计细节

### 1. 缓冲区

缓冲区是前端和后端之间通信的桥梁。

如图所示，准备两块缓冲区 Buffer A 和 Buffer B，前端负责往 Buffer A 中写入日志消息，后端负责将 Buffer B 中的日志消息写入文件：

![alt text](photos/logger1.png)

当 Buffer A 写满之后，交换 A 和 B，让后端将 Buffer A 中的日志消息写入文件，而前端则往 Buffer B 中写入新的日志消息，如此反复。

![alt text](photos/logger2.png)

在大部分的时间中，前端线程和后端线程不会操作同一个缓冲区，这也就意味着前端线程的操作，不需要等待后端线程缓慢的写文件操作，因为不需要锁定临界区。

前端线程和后端线程仅仅只在交换缓冲区时会存在线程同步问题，因此只需要在交换缓冲区时使用互斥锁来保护临界区即可，这个时间极其短暂，这也就是提高吞吐量的关键所在。

同时，后端线程将缓冲区中的日志消息写入到文件系统中的频率，完全由自己的写入策略来决定，避免了每条新的日志消息都唤醒后端线程。

换言之，前端线程不是将一条条日志消息分别传送给后端线程，而是将多条消息组成一个大的 Buffer 传递给后端进行处理，相当于批量处理，减少了线程唤醒的频率和 IO 操作次数，降低开销。

在 Muduo 的实现中，在后端设置了一个已满缓冲区的队列，用于缓冲一个周期内临时要写的日志消息：

![alt text](photos/logger3.png)

### 2. LogStream

FixedBuffer 类是作为 LogStream 类类型的缓冲区对象，其是一个模板类，传入一个非类型参数 SIZE 用来表示缓冲区的大小，其示意图如图所示：

![alt text](photos/logger4.png)

如图所示，其在栈上维护一段大小为 SIZE 的内存区域，length 为已写入数据的长度，而 avail 为剩余可用的数据长度。

SmallBuffer 的默认大小为 4KB，为前端的 LogStream 所持有。而 LargeBuffer 的默认大小为 4MB，为后端 的 AsyncLogging 所持有。

对于 LogStream 类类型来说，它将要输出的信息加载到 FixedBuffer 的缓冲区中，等待后续的处理。它通过重载 << 运算符来输出基本的数据类型到缓冲区。各种输入类型的调用链如下所示：

![alt text](photos/logger5.png)
    注意：LogStream 不是线程安全的，因此对于每个 log 消息应当构造一个临时的 LogStream，用完之后随即销毁。

在该类中，设计了大量的运算符重载函数，其效率要优于 iostream 和 stdio，使用的思想源于 Matthew Wilson 的 “带符号整形数据的除法与余数” 算法实现。其巧妙之处在于，用一个对称的 digits 数组搞定了负数转换的边界条件(二进制补码的正负数表示范围不对称):
```C++
const char digits[] = "9876543210123456789";
````
此外，由于 LogStream 本身并不支持格式化，因此设计 Fmt 类类型将数值类型数据转化为一个长度不超过 32 位的字符对象 Fmt，并重载了支持 Fmt 输出到 LogStream 的 << 操作符模板函数。

### 3. Logging

在 Logger 类中定义了枚举变量 LogLevel 来作为日志等级：

| 日志等级 | 说明 |
| ----- | ----- |
|TRACE	|跟踪：指明程序的运行轨迹，比 DEBUG 级别的粒度更细|
|DEBUG	|调试：指明细致的事件信息，对调试应用最有用|
|INFO	|信息：指明描述信息，从粗粒度上描述了应用的运行过程|
|WARN	|警告：指明可能潜在的危险情况|
|ERROR	|错误：指明错误事件，但应用可能还能继续运行|
|FATAL	|致命：指明非常严重的可能导致应用终止执行的错误事件|